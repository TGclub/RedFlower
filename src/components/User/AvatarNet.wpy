<style lang="scss" type="text/scss">
    @import "../../common/styles/variables.scss";
    @import "../../common/styles/mixins.scss";
    @import "../../common/styles/common.scss";

    .net{
		&-container{
			position: relative;
			width: 750rpx; 
        	height: 840rpx; 
			overflow: hidden;
		}
		&-userhead{
			position: absolute;
			width: 340rpx;
			height: 340rpx;
			top: 232rpx;
			left: 204rpx;
			transition: opacity 1s;
		}
		&-rings{
			position: absolute;
			width: 100%;
			height: 100%;
		}
		&-transport{
			transition: all 1s;
			overflow: hidden;

			image{
				width: 100%;
				height: 100%;
				border-radius: 50%;
			}
		}
	}
</style>

<template>
    <view class="net-container">
        <!-- 用户中心头像显示 -->
        <view class="l-rowAllMid net-userhead"  style='opacity: {{userhead.opacity}};'>
            <image class="net-rings" src='../../static/images/contacts/rings.png'></image>
            <ava :info='userhead' :opacity='userhead.opacity'></ava>
		</view>

        <!-- 人脉网显示 -->
        <repeat for="{{avaList}}" item="item" index='idx'>
			<ava :info='item' @avaClick.user='changeUser' :opacity='avaListopacity' :display='avaListshow'></ava>
		</repeat>

        <!-- 为完成点击头像切换人脉网效果而设置的特殊模块 -->
        <view class='net-avatar net-transport absolute' style="width: {{transport.size}}rpx; height: {{transport.size}}rpx; top: {{transport.top}}rpx; left: {{transport.left}}rpx; display: {{transport.show}}">
            <image src='{{transport.src}}'></image>
        </view>
    </view>
</template>

<script>
    import wepy from 'wepy'
	import Avatar from './Avatar'
	// import API from '../../API/index'
	// import * as WXUTIL from '../../common/scripts/wxUtil'
    
    /*
     * {props}: usersrc: 用户头像链接/ srclist: 用户好友头像链接
     */
	export default class AvatarNet extends wepy.component {
        components = {
            ava: Avatar
		}
		
		props = {
			usersrc: {
				type: String
			}, 
			srclist: {
				type: Array
			}
		}

        data = {
			// maxHigh假数据
			maxHigh: 840,
			userhead: {
				src: '',
				size: '204',
				opacity: '1'
			},
			avaListopacity: 1,
			avaListshow: 'block',
			avaList: [],
			transport: {
				show: '',
				src: '',
				size: '',
				top: '',
				left: ''
			}
		}

		events = {
			changeGroup (e) {
				if (this.avaList1opacity === '1') {
					this.avaList1opacity = '0';
					this.avaList2show = 'block';

					setTimeout(() => {
						this.avaList2opacity = '1';
						this.avaList1show = 'none';
						this.$apply();
					}, 1000)

					this.$apply();
					return ;
				} if (this.avaList2opacity === '1') {
					this.avaList2opacity = '0';
					this.avaList3show = 'block';

					setTimeout(() => {
						this.avaList3opacity = '1';
						this.avaList2show = 'none';
						this.$apply();
					}, 1000)

					this.$apply();
					return ;
				} if (this.avaList3opacity === '1') {
					this.avaList3opacity = '0';
					this.avaList1show = 'block';

					setTimeout(() => {
						this.avaList1opacity = '1';
						this.avaList3show = 'none';
						this.$apply();
					}, 1000)

					this.$apply();
					return ;
				}
			},
		}

		methods = {
			// 还应在此方法中向主页发起请求，用于刷新用户好友头像列表
			changeUser (e) {
				console.log(e.currentTarget)
				const listNum = (e.currentTarget.id).slice(7, 8);
				const idx = (e.currentTarget.id).slice(8);
				
				let avaList = [];

				// 消失动画
				switch (listNum) {
					case '1':{
						this.avaList1opacity = '0';
						avaList = this.avaList1;

						setTimeout(() => {
							this.avaList1show = 'none';
							this.$apply();
						}, 1000)

						break;
					}
					case '2':{
						this.avaList2opacity = '0';
						avaList = this.avaList2;

						setTimeout(() => {
							this.avaList2show = 'none';
							this.$apply();
						}, 1000)

						break;
					}
					case '3':{
						this.avaList3opacity = '0';
						avaList = this.avaList3;

						setTimeout(() => {
							this.avaList3show = 'none';
							this.$apply();
						}, 1000)

						break;
					}
				}
				this.userhead.opacity = '0';

				// 移位动画
				this.transport.src = avaList[idx].src;
				this.transport.size = avaList[idx].size;
				this.transport.top = avaList[idx].top;
				this.transport.left = avaList[idx].left;
				this.transport.show = 'block';

				this.$apply();

				setTimeout(() => {
					this.transport.size = '204';
					this.transport.top = '296';
					this.transport.left = '270';
					this.$apply();
				}, 1000)
				

				setTimeout(() => {
					this.userhead.opacity = '1';
					this.userhead.src = this.transport.src;
					this.avaList1show = 'block';
					
					this.$apply();
				}, 2000)
				
				// 清除移位容器状态，为下次动画做准备
				setTimeout(() => {
					this.avaList1opacity = '1';

					this.transport.show = 'none';
					this.transport.src = '';
					this.transport.size = '';
					this.transport.top = '';
					this.transport.left = '';

					this.$apply();
				}, 3000)
			},
			jumpToGroups (e) {
				wx.navigateTo({
					url: './contacts/groups'
				})
			}
		}

		onLoad () {
			// 获取窗口高度
			// console.log($WX.getSystemInfo())

			this.userhead.src = this.usersrc;
			/**
			* @desc 生成[-1, 1]之间的随机值
			* @return {number} 随机值
			*/
			const _rnum = () => {
				const flag = Math.random()
				const rnum = flag > 0.5 ? Math.random() : -Math.random();
				return rnum;
			}

			/**
			* @desc 生成随机点
			* @param w {number} 画布宽度
			* @param h {number} 画布高度
			* @return {object} 随机点坐标
			*/
			const _rollSeed = () => {
				const x = parseInt(315 * Math.random());
				const y = parseInt(60 * Math.random() + 60);

				return {x: x, y: y};
			}

			/**
			* @desc 碰撞检测
			* @param pointA {object} A目标坐标、半径
			* @param pointB {object} B目标坐标、半径
			* @return {boolean} 是否重叠
			*/
			const _isOverlay = (pointA, pointB) => {
				const xGap = Math.abs(pointA.x - pointB.x);
				const yGap = Math.abs(pointA.y - pointB.y);
				const maxDiameter = 120;

				if (xGap > maxDiameter && yGap > maxDiameter) {
					return true;
				} else {
					return false;
				}
			}

			/**
			* @desc 合法性检测
			* @param point {object} 目标坐标、半径
			* @param posList {array} 已有位置列表
			* @return {boolean} 是否合法
			*/
			const _isValid = (point, posList = []) => {
				const x = point.x;
				const y = point.y;
				const radius = point.radius

				// x、y组合和已有位置发生碰撞
				for(let i = 0; i < posList.length; i++) {
					if (_isOverlay(point, posList[i])) {
						continue;
					} else {
						return false;
					}
				}

				// 检查完成
				return true;
			}
			
			/**
			* @desc 生成合法位置列表
			* @param seed {object} 种子坐标
			* @return {array} 合法位置列表
			*/
			const posListFactory = (seed = {x: 310, y: 112}) => {
				let h = this.maxHigh;
				let x = seed.x;
				let y = seed.y;
				let partern = x > 150 ? 1 : 2;
				let srcPos = [];

				// 生成四个大圆的坐标
				for (let i = 0; i < 4; i++) {
					let randomFactor = 15 * Math.random();
					let pos = {radius: 60, x: randomFactor, y: randomFactor};

					switch (i) {
						case 0: {
							pos.x += x;
							pos.y += y;
							break;
						}
						case 1: {
							pos.x += 750 - 120 - y;
							pos.y += x;
							break;
						}
						case 2: {
							pos.x += 750 - 120 - x;
							pos.y += h - 120 - y;
							break;
						}
						case 3: {
							pos.x += y;
							pos.y += h - 120 - x;
							break;
						}
					}

					this.avaList.push(pos);
				}
				
				// 根据显示模式生成五个小圆坐标
				{
					if (partern === 1) {
						this.avaList.push({radius: 35, x: 275 + 10 * _rnum(), y: h - 90 + 10 * _rnum()});
						// 通过对大圆坐标加减来得到小圆坐标

						// for (let i = 0; i < 5; i++) {
						// 	let temp = {radius: 35};

						// 	temp.x = (10 * _rnum() + srcPos[i].x);
						// 	temp.y = (10 * _rnum() + srcPos[i].y);
						// 	this.avaList.push(temp);
						// }
					} else {
						this.avaList.push({radius: 35, x: 275 + 10 * _rnum(), y: 90 + 10 * _rnum()});
					}

					// for (let i = 0; i < 5; i++) {
					// 	let temp = {radius: 35};

					// 	temp.x = (10 * _rnum() + srcPos[i].x);
					// 	temp.y = (10 * _rnum() + srcPos[i].y);
					// 	this.avaList.push(temp);
					// }
				}

				console.log(this.avaList);
			}

			posListFactory(_rollSeed());

			this.$apply();
		}
	}
</script>
